interface Shape {
    val numberOfSides: Int

    fun calculateArea() : Double
}

class Square : Shape {
    override val numberOfSides: Int = 4

    override fun calculateArea(): Double {
        return 2.0
    }
}

class Triangle : Shape {
    override val numberOfSides: Int = 3

    override fun calculateArea(): Double {
        return 1.5
    }
}

fun isCoolShape(someShape: Shape) : Boolean {
    return true
}

class MathThing {
    init {
        val square = Square()
        val triangle = Triangle()

        isCoolShape(square)
        isCoolShape(triangle)
    }
}


/*
class Pitch(val pitchClass: Char, val accidental: String, val octave: Int) {
    init {
        // require(octave > 0)

        if (
            octave < 1 ||
            octave > 11 ||
            (pitchClass == 'A' && octave > 10) ||
            (pitchClass == 'B' && octave > 10) ||
            (pitchClass == 'C' && accidental == "flat" && octave == 1)
            ) {
            throw IllegalStateException("invalid value")
        }
    }

    val midiValue: Int = when (pitchClass) {
        'A' -> 9
        'B' -> 11
        'C' -> 0
        'D' -> 2
        'E' -> 4
        'F' -> 5
        'G' -> 7
        else -> throw IllegalStateException("invalid pitchClass value")
    } + ((octave - 1) * 12)

    val equivalents: String = ""
}
*/

/*
class Entry {}

class Scale {}

class Key {}

class Quality {}

class Inversion {}

class Position {}

class Interval {}

class MidiValue() {

}

 */

class Pitch2 {}

class PitchClass(
    val midiValue: Int
) {
    fun determinePitchClass(): String {
        val workingValue: Int = midiValue % 12

        when (workingValue) {
            0 -> return "C"
            1 -> return "C#/Db"
            // TODO etc
            else -> return "Error"
        }
        // TODO C# and Db need to depend on context? scale / key / chord etc
        // TODO midiValue is the objective value, everything else is context based
        // TODO button to switch sharp and flat option ?
        // TODO so, maybe we create, for example, both the C# minor chord and Db minor chord,
        //  and have logic to determine which one has priority, but still have the other one
        //  as an option
        // TODO option to interpret a chord from the context of any key???
    }
}

class Note(
    val midiValue: Int
) {
    // TODO contains midiValue as well as pitch class
    // TODO relevancy score to decide between sharp and flat?
    // TODO context class?
}

/*
fun String.convertChordNameToNotes() : List<Note> {
    this.length
    return emptyList()
}
 */

/*
fun convertChordNameToNotes2(
    chordName: String
) : List<Note> {
    chordName.length
    return emptyList()
}

 */

class Chordscrap(
    val notes: List<Note>, val chordName: String
) {
    /*
    constructor(chordName: String) : this(chordName.convertChordNameToNotes(), chordName) {

    }

     */
    /*
    constructor(chordName: String) : this(convertChordNameToNotes2(chordName), chordName) {

    }
     */

    constructor(chordName:String) : this(convertChordNameToNotes3(chordName
    ), chordName) {

    }

    val chordInterpretationsList: MutableList<ChordInterpretationscrap> = mutableListOf()

    // TODO maybe not init, if the Chord class is also used when the chord is entered and a known quantity?
    // interpret chord in initializer block
    init {
        // iterate through possible interpretations using each pitch as the root note
        for (root in notes) {
            // separate non-root notes from root note by adding them into otherNotes variable
            val otherNotes: MutableList<Note> = mutableListOf()

            for (note in notes) {
                if (note != root) {
                    otherNotes.add(note)
                }
            }

            // add ChordInterpretation to chordInterpretationsList
            chordInterpretationsList.add(ChordInterpretationscrap(root = root, otherNotes = otherNotes))
        }

        // TODO weigh different interpretations against each other (3rd? 5th?)
        // TODO add to relevancy score as you go
        // TODO if rootNote == bassNote
        // TODO number of pitches variable?
    }

    companion object {
        fun convertChordNameToNotes3(
            chordName: String
        ) : List<Note> {
            chordName.length
            return emptyList()
        }
    }
}

class ChordSpellingscrap {
    init {
        Chordscrap.convertChordNameToNotes3("A Major")
    }
}

class ChordInterpretationscrap(
    val root: Note,
    val otherNotes: List<Note>
) {
    var hasMinorSecond: Boolean = false
    var hasMajorSecond: Boolean = false
    var hasMinorThird: Boolean = false
    var hasMajorThird: Boolean = false
    var hasFourth: Boolean = false
    var hasTritone: Boolean = false
    var hasFifth: Boolean = false
    var hasMinorSixth: Boolean = false
    var hasMajorSixth: Boolean = false
    var hasMinorSeventh: Boolean = false
    var hasMajorSeventh: Boolean = false
    var hasOctave: Boolean = false
    var hasMinorNinth: Boolean = false
    var hasMajorNinth: Boolean = false
    var hasAugmentedNinth: Boolean = false

    init {

    }

    // TODO decide when interval context is determined? semi dependent on what else?
    // TODO decide where chord quality logic is handled


    // maybe this class is just an array and is unnecessary???
    // TODO take notes in, in order
    // TODO calculate intervals, set to true or false ex: hasThird, switch statement
    // TODO calculate quality, intervals, etc, but deciding interpretation of root note (ex: C# / Db) has to consider scale, or #/b toggle ?

}



// code from wizard
/*
@Composable
@Preview
fun App() {
    MaterialTheme {
        var showContent by remember { mutableStateOf(false) }
        Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
            Button(onClick = { showContent = !showContent }) {
                Text("Click me!")
            }
            AnimatedVisibility(showContent) {
                val greeting = remember { Greeting().greet() }
                Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
                    Image(painterResource(Res.drawable.compose_multiplatform), null)
                    Text("Compose: $greeting")
                }
            }
        }
    }
}
*/

// code from session with joe
/*
@Composable
fun App() {
    MaterialTheme {
        var navstate: Int by remember { mutableStateOf(0) }

        Scaffold(
            topBar = {

            },
            bottomBar = {
                BottomNavigationBar(
                    navstate = navstate,
                    OnNavstateUpdate = { value: Int -> navstate = value }
                )
            }
        ) {
            Column{
                if (navstate == 0) {
                    Screen1()
                } else if (navstate == 1) {
                    Screen2()
                }
            }
        }
    }
}

@Composable
fun Screen1() {
    Text(text = "Screen 1")
}

@Composable
fun Screen2() {
    Text(text = "Screen 2")
}

sealed class BottomNavItem(val icon: ImageVector, val label: String) {
    object Home : BottomNavItem(Icons.Default.Home, "Home")
    object Search : BottomNavItem(Icons.Default.Search, "Search")
    object Profile : BottomNavItem(Icons.Default.Person, "Profile")
}

@Composable
fun BottomNavigationBar(
    navstate: Int,
    OnNavstateUpdate: (Int) -> Unit
) {
    BottomNavigation {
        val navItem1 = "Tab 1"
        val navItem2 = "Tab 2"
        BottomNavigationItem(
            selected = if (navstate == 0) true else false,
            onClick = { OnNavstateUpdate(0) },
            icon = { Icon(Icons.Default.Person, null) },
            label = { Text(navItem1) })
        BottomNavigationItem(
            selected = if (navstate == 1) true else false,
            onClick = { OnNavstateUpdate(1) },
            icon = { Icon(Icons.Default.Person, null) },
            label = { Text(navItem2) })
    }
}
*/



